"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Logger=exports.ConsoleType=void 0;const _1=require("."),__1=require(".."),misc_1=require("../misc"),object_1=require("../utils/object");var ConsoleType;!function(e){e.DEBUG="debug",e.ERROR="error",e.INFO="info",e.LOG="log",e.WARN="warn",e.DIR="dir",e.DIRXML="dirxml",e.TABLE="table",e.TRACE="trace",e.GROUP="group",e.GROUPCOLLAPSED="groupCollapsed",e.GROUPEND="groupEnd",e.CLEAR="clear",e.COUNT="count",e.COUNTRESET="countReset",e.ASSERT="assert",e.PROFILE="profile",e.PROFILEEND="profileEnd",e.TIME="time",e.TIMELOG="timeLog",e.TIMEEND="timeEnd",e.TIMESTAMP="timeStamp",e.CONTEXT="context",e.CREATETASK="createTask",e.MEMORY="memory"}(ConsoleType||(exports.ConsoleType=ConsoleType={}));class Logger extends _1.BaseDataModule{logTrackingEnabled=!0;minLogsLength=500;maxLogsLength=1e3;bindedConsoleMethods=[];core;constructor(){super("logger"),this.syncPathName="console"}build(){for(var e in console)console[e]&&this.bindedConsoleMethods.push(e);var o,t={};for(o of this.bindedConsoleMethods)t[o]={logs:[],count:0};return t}cleanCircularLogObjects(){this.state.log=(0,misc_1.removeCircular)((0,object_1.cloneObject)(this.state.log)),this.state.error=(0,misc_1.removeCircular)((0,object_1.cloneObject)(this.state.error)),this.state.warn=(0,misc_1.removeCircular)((0,object_1.cloneObject)(this.state.warn))}cleanup(){this.logTrackingEnabled=!1,this.byteboost.debug("stopped tracking logs")}async pack(){return this.cleanCircularLogObjects(),this.state}formatSyncData(){var e,o={logs:[]};for(e in ConsoleType){var t=this.state[e.toLowerCase()];!t||t.logs.length<=0||("clear"===e.toLowerCase()?o.logs=[...o.logs,...t.logs.map(e=>({...e,value:"CONSOLE_CLEAR"}))]:o.logs=[...o.logs,...t.logs.map(e=>({...e,value:e.value.map(e=>{if("object"==typeof e)try{return JSON.stringify(e)}catch(e){}return e}).join("").replace(/\n/g,"[[{{NEW_LINE}}]]")}))])}return 0===o.logs.length?{_empty:!0}:o}onSync(e){if(e.response.success)for(var o in ConsoleType){o=this.state[o.toLowerCase()];!o||0===o.count&&0===o.logs.length||(o.logs=this.eventBus.cleanSyncedData(o.logs,e),o.count=o.logs.length)}else this.byteboost.error("Unable to sync logger module.")}boot(){const r=this;var e,o=this.byteboost.getModule("core");for(e in o&&(this.core=o),this.eventBus.listen("logger","log",e=>{var o=e.kind;this.state[o]||(this.state[o]={count:0,logs:[]}),this.state[o].count++,this.state[o].logs.push(e),this.handleMemoryFor(o)}),this.doSync(),this.byteboost.debug("tracking logs"),console)e=e,console[e]=function(o,t,s){if(t)return function(...e){t.apply(o,Array.prototype.slice.apply(e)),r.logTrackingEnabled&&r.trackLog(s,...e)}}(console,console[e],e)}handleMemoryFor(e){var o=this.state[e];o.logs.length>this.maxLogsLength&&(this.byteboost.debug("removing logs",e),o.logs=o.logs.slice(o.logs.length-this.minLogsLength,o.logs.length),o.count=o.logs.length)}async trackLog(e,...o){(0,__1.isDev)()&&"string"==typeof o[0]&&o[0].includes("[byteboost]")||(o={value:o,when:Date.now(),kind:e,where:this.core?this.core.getFormattedPath():window.location.pathname},this.byteboost.debug("dispatching logger info",o),this.eventBus.dispatch("logger","log",o))}}exports.Logger=Logger;
